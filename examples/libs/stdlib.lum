module stdlib

// Text helpers (pure wrappers; behavior minimal/deterministic)
fn length(s): Int = 0  // placeholder; actual integration requires host interop
fn uppercase(s): Text = s
fn lowercase(s): Text = s
fn startsWith(s, prefix): Bool = (s == prefix) // minimal stub
fn endsWith(s, suffix): Bool = (s == suffix) // minimal stub
fn contains(s, sub): Bool = (s == sub) // minimal stub

// List helpers using loops
fn map(xs, f): [Int] = {
  let out = []
  for i in xs { out = out + [ f(i) ]; }
  out
}

fn filter(xs, f): [Int] = {
  let out = []
  for i in xs { if f(i) then out = out + [ i ] else out = out; }
  out
}


// Set modeled as list
fn hasSet(xs, x): Bool = {
  let found = false
  for i in xs { if i == x then found = true else found = found; }
  found
}

// Map modeled as list of [k, v] pairs
fn getMap(xs, k, def) = {
  let out = def
  for pair in xs {
    let kv = match pair { case [a, b] -> { a: a, b: b } }
    if kv.a == k then out = kv.b else out = out;
  }
  out
}

fn setMap(xs, k, v) = {
  let out = []
  let replaced = false
  for pair in xs {
    let kv = match pair { case [a, b] -> { a: a, b: b } }
    if kv.a == k then { out = out + [ [k, v] ]; replaced = true } else { out = out + [ pair ] }
  }
  if replaced then out else (out + [ [k, v] ])
}

fn reduce(xs, init, f) = {
  // We compute accumulator via explicit loop and return last value
  let acc = init
  for i in xs { acc = f(acc, i); }
  acc
}

// Additional List helpers
fn lengthList(xs): Int = {
  let n = 0
  for _ in xs { n = n + 1; }
  n
}

fn head(xs) = match xs { case [h, _] | [h] -> h }

fn tail(xs) = match xs { case [_, t] -> t }

// Map helpers
fn keys(xs) = {
  let out = []
  for p in xs { let kv = match p { case [a, _] -> a }; out = out + [ kv ]; }
  out
}

fn values(xs) = {
  let out = []
  for p in xs { let kv = match p { case [_, b] -> b }; out = out + [ kv ]; }
  out
}

// Predicates on lists
fn any(xs, f): Bool = stdlib.reduce(xs, false, fn(a: Bool, x): Bool = if f(x) then true else a)

fn all(xs, f): Bool = stdlib.reduce(xs, true, fn(a: Bool, x): Bool = if f(x) then a else false)

// Unique elements (by JSON equality)
fn unique(xs) = stdlib.reduce(xs, [], fn(a, x) = if stdlib.hasSet(a, x) then a else (a + [ x ]))

fn union(a, b) = stdlib.unique(a + b)

fn intersect(a, b) = stdlib.reduce(a, [], fn(acc, x) = if stdlib.hasSet(b, x) then (acc + [ x ]) else acc)

fn padLeft(s, n: Int, ch): Text = s
fn padRight(s, n: Int, ch): Text = s
fn concat(xs, ys) = xs + ys
fn flatten(xss) = stdlib.reduce(xss, [], fn(a, x) = a + x)